================================================================================
                                    Bytecode
================================================================================

Notes / ideas
=============
I'm not having much of a clue what I'm doing here, it might also be a bit
premature to think about the bytecode before the syntax and semantics are clear.

Special type coding for integers? Con: implementation becomes less generic
- ?? nothing?
- 00 block
- 01 function
- 10 unsigned long int (62-bit)
- 11 long int (62-bit)

Datatypes / values
==================

2 (3?) basic datatypes
- Nothing?
- Block / instance / class / prototype
  - Variable-length code for class?
  - number of elements (size)
  - optionally instance contents
- Function
  - list of parameters (with names and default values) and return values
  - class

What to do for values of native types (fn.["()"] and number.value)?
- make them return themself? fn.["()"] == fn and number.value == number?
  - would make sure every value is of "Block" / "Object" basic datatype,
    no datatype storage needed (saves a couple bits, don't know if necessary)
  - store actual value in some kind of metadata?
- extra (3rd?) basic type: native/internal blob, storing value?
  - con: possibly extra indirection
- no number.value, fn.["()"] is other (native) function with ["()"] set
  to itself, like javascript function.call: fn.["()"].["()"] == fn.["()"]
  - store actual value in some kind of metadata / userdata?

Variables / fields
==================
Some way to not have to allocate for simple types (numbers)!

- modifiers: private, const, static
- type? possible data duplication, type is also stored in value
- data or pointer, plus something to indicate which of the two
  - idea: allocate object members directly after object header,
    relative pointers would improve locality and allow for smaller header size
	(relative offset can be int or even short, in steps of base size = 2*long?)



================================================================================
                                Interpreter / VM
================================================================================
https://craftinginterpreters.com/contents.html

Ideas
=====
- For functions returning closures, somehow store the returned function inside
  the outer function to prevent re-creating functions every time



================================================================================
                                      API
================================================================================



================================================================================
                            	Standard library
================================================================================
https://en.wikipedia.org/wiki/Abstract_data_type#Examples_2
