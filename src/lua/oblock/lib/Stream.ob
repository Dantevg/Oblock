var Stream
Stream = {
	of(source) => {
		iterator = source.iterate()
		return this.clone {
			read = id.o iterator
		}
	}
	
	iterate() => this.read
	
	"..." () => {
		const values = []
		for value in this: values.append value
		return ...values
	}
	
	-- FILTERS
	-- These functions transform a stream into another stream
	
	map(fn) => this.clone {
		const source = this
		read() => {
			val = source.read()
			return if val != nil: fn(val)
		}
	}
	
	mapIndex(object) => this.map(x => object.(x))
	
	forEach(fn) => this.clone {
		const source = this
		read() => {
			val = source.read()
			if val != nil: fn(val)
			return val
		}
	}
	
	filter(fn) => this.clone {
		const source = this
		read() => {
			for x in source: if fn(x): return x
			return nil
		}
	}
	
	take(n) => this.clone {
		const source = this
		taken = 0
		read() => {
			if taken < n: {
				taken += 1
				return source.read()
			}
			return nil
		}
	}
	
	drop(n) => this.clone {
		const source = this
		dropped = 0
		read() => {
			while dropped < n: {
				dropped += 1
				source.read()
			}
			return source.read()
		}
	}
	
	group(fn, keepEmpty) => this.clone {
		const source = this
		buffer = []
		read() => {
			for x in source: {
				if fn(x, buffer.(buffer.length), buffer.length): {
					buffer.append(x)
				} else if buffer.length > 0 or keepEmpty: {
					const oldBuffer = buffer
					buffer = if fn(x, nil, 0): [x] else []
					return Stream.of(oldBuffer)
				}
			}
			-- Source is empty, buffer still has items
			if buffer.length > 0: {
				const oldBuffer = buffer
				buffer = []
				return Stream.of(oldBuffer)
			}
			return nil
		}
	}
	
	groupBySize(size) => this.group((_, __, s) => s < size)
	
	splitAt(at, keepEmpty) => this.group(x => x != at, keepEmpty)
	
	sorted(fn) => this.clone {
		const source = this
		var values
		read() => {
			if !values: values = Stream.of([...source].sorted(fn))
			return values.read()
		}
	}
	
	-- SINKS
	-- These functions transform a stream into a single value
	
	reduce(fn, acc) => {
		acc = acc or this.read()
		for x in this: acc = fn(acc, x)
		return acc
	}
	
	max() => this.reduce((acc, x) => Number.max(acc, x))
	min() => this.reduce((acc, x) => Number.min(acc, x))
	sum() => this.reduce((acc, x) => acc + x)
	count() => this.reduce((acc, x) => acc + 1, 0)
	
	forAll(fn) => for x in this: fn(x)
	
	any(predicate) => {
		for x in this: if predicate(x): return true
		return false
	}
	
	all(predicate) => {
		for x in this: if !predicate(x): return false
		return true
	}
}

yield Stream
