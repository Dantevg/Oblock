================================================================================
                                     Syntax
================================================================================
https://wren.io/classes.html

To-Do / roadmap / proposals
===========================
- Newlines and other statement/expression separators
- Generic types? maybe later, if needed
- Default parameters?
- `...` keyword, like in Lua
- Named parameters by (<arg> = <exp>)
  - Following C# valid-ness, valid when one of:
    - First all positional parameters, then all named parameters
    - Named parameters in correct place?
- Passing single block as parameter
  - "Immediately-invoked function"
  - Allows positional arguments and named arguments
  - Automatically "destructured" to function call
  - Problem: what to do when you want to pass a single block parameter? (syntax)
  - Solution: maybe use list/array syntax (which may use '()' already, how convenient!)
  - Problem again: list syntax is syntax sugar for block extending List, still same problem
- Compound assignment operators?
- Statements as expressions?
  - New style: var a = if x > 10: "greater" elseif x == 10: "equal" else: "smaller"
  - In Lua style: var a = x > 10 and "greater" or (x == 10 and "equal" or "smaller")
  - https://news.ycombinator.com/item?id=8827843
  - I think not for all statements, because waste of memory if return value
    is not used (loops create lists?)
  - Maybe make assignment an expression
    - Pro: terse `a = b = c` (needs to be right-associative for this: `a = (b = c)`)
    - Con: cryptic "code-golf" things
    - Con: possible mistakes like `while x = 1`
- Keyword for binary actual data layout in const classes like Int (8 bytes for long long)?
  - Maybe define class instance size in bytes for const classes: sizeof(struct MyClass) in C?
    - should you need to define size for foreign/external classes *within* the language?
      maybe makes creating classes too much work: when changing internal size, need to recalculate "by hand"
- Comment syntax:
  - C-like: // and /* */
  - Lua-like: -- and --[[ ]] works well in combination with long/raw strings
  - Might not be needed: strings as statements as comments (but does not work within expressions: lists)
- Pointers / references
- Enums
  - Boolean should be an enum with 2 values? true and false are the only 2 instances of Bool
  - Maybe like Java?
  - Enum instance (true, false, colours) is const instance with no values,
    enum "class" itself should be const as well (but do not enforce)
- Ternary operator? Don't think, I like lua's and-or method
- Type cast operator? to let nil/null and false both evaluate falsy
  - No type casting, but instead .toInt, .toBoolean methods or use Int(), Bool() constructors
  - Type casting with different syntax: '<>' maybe?
    - Problem: clashes with comparison operators (see below)
  - Type casting with 'as' keyword: `5.2 as Int`
  - Problem: should not be able to make custom types falsy.
- Pure functions as optimisation?
- Less generalised than hoped: language syntax needs literals for numbers and strings
- allow custom wrap operators? like '<>' would be nice, or '||'
  - disallow defining of predefined wrap operators as unary or binary operators!
  - problem: interfering with allowing single-param function call without parentheses:
      a | b | c
      as 2x binary operator: (a | b) | c
      as wrap operator and function call: a |b| c  (which is  a(|b|)(c) or a(|b|(c)))
    - possible (bad) solution: require no space present inside "brackets"
      - problem for strings: " airy string "
    - other solution: disallow function call without brackets (but I want to have this!)
    - better solution: set wrap operator precedence(?) such that this is not a problem (really low?)
      - con: you will often need to use brackets around every wrap operator: a (|b|) c
  - maybe best to disallow custom wrap operators but have a few default unassigned
- problem: does the wrap operator apply on only the content or also the expression before?
  - a[b] should call '[]' from a with b as argument: a.[](b)
    - definition of '[]' method should be defined in class of a
  - a [b] should call '[]' with b as argument and pass that as argument to a: a([](b))
    - definition of '[]' method should be defined in its own operator class
      (see operators as first-class citizens ^)

Operators and keywords
======================
- precedence
- associativity
- operators and keywords as first-class citizens? Would allow using all things as keys (and values)
  - as keys for defining operator methods
  - as values for storing and passing to functions
  - problem: how to use operators from parameters?
    - use any value as operator like haskell? not nice for readability
  - operators as classes? define operator instance methods inside operator's class
    instead of inside type's class:
    - + = { ()(a: Num, b: Num) => a + b } (would need to define this method on Num class load)
    - Num = { +(b) => this + b }
- keywords: return, yield (maybe later, together with coroutines/continuations), break, throw?
  - External / foreign? for function definitions that get populated later on by C or as interfaces
- true, false and nil/null are not keywords, but instances of Bool and Nil/Null classes
- unary operators: '-', '!' and other custom ones
- binary operators: '-', '+' and other custom ones
- wrap operators: '{}', '()', '[]', '""' (n-ary operators)
  - '()' serves multiple purposes, but in different contexts this should be ok:
    - expression: grouping
    - function call: argument list
    - function definition: parameter list
- index operators: '.' and '[]'
  - a.b is syntax sugar for a["b"]
  - when used in an expression, they are binary operators, called on the left
    operand with the right (or enclosed) operand as argument
  - when used in a variable definition, they are ternary operators, called
    just like in an expression context, but also with the value as second argument

Statements and expressions
==========================
Blocks, classes and function bodies are all the same
In general, newlines are ignored and seen as whitespace (like Lua).

The following:
	a
	-b
	.c()
gets parsed as expression:
	a - b .c()
	which is
	a - (b.c())
But this:
	a
	-b
	c()
gets parsed as expression followed by statement:
	a - b c()
	which is
	a - b
	c()
This means ?

Formal syntax
=============
- exp ::= var | number | string | exp binop exp | unop exp | wrapopl exp wrapopr
        | block | lambda | fncall | varlist '=' explist | '(' exp ')'
- stat ::= sep
         | varlist '=' explist
         | exp
         | {modifier} identifier ['(' arglist ')'] '=>' chunk
         | 'if' exp ':' chunk {'elseif' exp ':' chunk} ['else' chunk]
         | 'while' exp ':' chunk
         | 'for' varlist 'in' explist ':' chunk
- chunk ::= stat  |  block
- block ::= {modifier} '{' {stat} '}'
- lambda ::= '(' arglist ')' '=>' chunk
- identifier ::= letter [{alphanum}]  |  '`' {character} '`'
- fncall ::= exp args
- args ::= exp  |  '(' [explist] ')'
- varlist ::= {modifier} var {sep {modifier} var}
- explist ::= exp {sep exp}
- sep ::= '\n' | ';' | ','

List / array syntax using `()` or `[]` as syntax sugar. These are all equal:
[10, 20, a = b, 30]
[
	10
	20
	a = b
	30
]
extend List {
	`1` = 10
	`2` = 20
	a = b
	`3` = 30
}

Inheritance:
- Point = Vector { } (call static superclass)
- Point = extend Vector { } (with `extend` keyword)
- Point = { @extend Vector } (with @attribute annotation)

Example
=======
Point = { (Point is a block/class/object, but really an immediately-invoked function)
	static `()`(x, y) => { (call method for Point "class" / object)
		this.x = x
		this.y = y
	}
	`+`(p) => Point(this.x + p.x, this.y + p.y) (addition method for Point instances)
	getX => this.x ("getter method", no argument list, will be invoked on myPoint.getX)
	setX(x) => { this.x = x } (normal method, assignments are not expressions so brackets necessary)
	
	static base = { (static immediately-invoked function, block: Point.base = 11)
		x = 10
		return x + 1
	}
	static next = static.base + 1 (static "immediately-invoked function", really just a field)
	static nget => static.base + 1 (static "getter method")
	static getBase() => Point.base (static shorthand method, Point.getBase() returns 11)
}

Functions
=========
- myFunction(x: Int): Int => {
	return x + 1
}
- callback () => 10
- callback (x: Int): Int => x + 1
- Optional types: (x: Int) or (Int x)
  - C-style:  Int myFunction(Int x) => x + 1 (can only be used in normal definitions)
  - TS / Kotlin-style: myFunction(x: Int): Int => x + 1 (can also be used in lambda definitions?)
- for definition: no space allowed between name and arglist, otherwise function application
- define associativity, which is more useful? `map increment myList` can be
  - `map(increment)(myList)` (functional style / currying?)
  - `map(increment(myList))`
- "Full" definition is syntax sugar for lambda style:
  - add(x, y) => x + y (definition as statement)
  - add = (x, y) => x + y (definition by assigning function expression)
- overloading based on arity, otherwise argument types when present
- Getters by using argument-less methods, setters?
- Parentheses can be omitted if only one argument passed on the same line



================================================================================
                                   Semantics
================================================================================
Self (this?) upvalue (keyword?)
- Only for instance (non-static) methods
- Refers to current instance

Static upvalue (keyword?)
- Refers to current block / class

Super upvalue (keyword?)
- Refers to superclass

Variable lookup
===============
- Function closures
1. locals (function arguments are locals)
2. (for instance methods) instance variables of current class (implicit `self.`/`this.`)
2.1. instance variables of superclass
3. static variables of current class (implicit `static.`)
3.1. static variables of superclass

Operators
=========
Operators defined in the class they apply to
Using an operator is simply calling the operator method on the leftmost(?) operand
- unary operators are simple
- binary operators are less simple because their second argument might not be of a usable type
- n-ary operators (wrap operators) are weird because the content does not really
  have anything to do with the result
  - application on first type is still possible: default operator in Object / Block base class
    creates a list of itself and its arguments

Modifiers
=========
Apply to variables (not values). By default, only `public` is applied implicitly.
- private and public: variable only accessable (readable/writable) within the same class
- const (and varying/changing/volatile?): cannot assign other value to variable
- static (and ??? instance? "dynamic" is weird): variable exists in class, instead of in its instances

- assign to const value: error
- read private value: yield nil/null?
- write private value: error? do nothing?

Blocks can have default modifiers, which apply to all variables inside
the block that are not marked the opposite:
Point = private {
	public getX => this.x (this method is public)
	setX(x) => { this.x = x } (this one is private)
}

Blocks
======
Blocks serve many purposes at once:
- Objects (storing values by string keys)
- Arrays (storing values by numeric keys)
- Maps? (storing values by any type keys)
- Classes (objects with constructors and instance variables/methods)
- Grouping of code chunks (if, while, for etc)
- Function contents (code chunks with parameters)

"Class" (block) constructors are static call operator methods
Prototype-based classes (seem more generic) with class-based syntax
